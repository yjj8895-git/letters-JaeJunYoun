<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Letters · Typing System – Shift Ball</title>
  <style>
    :root { --bg:#0b0b0b; --fg:#eaeaea; --muted:#9aa0a6; }
    html, body { height:100%; }
    body { margin:0; background:var(--bg); color:var(--fg); font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,Helvetica,Arial,sans-serif; overflow:hidden; }
    #stage { position:relative; width:100%; height:100%; }

    #hud, #sentencePanel {
      position:fixed; z-index:10; background:#121212cc;
      border:1px solid #2a2a2a; border-radius:10px; backdrop-filter: blur(8px);
    }
    #hud { left:10px; top:10px; padding:8px 10px; max-width:48vw; }
    #hud h1 { margin:0 0 4px; font-size:12px; color:#bdbdbd; }
    #hud p  { margin:0; font-size:11px; color:#cfcfcf; }

    #sentencePanel { right:10px; top:10px; padding:8px 10px; min-width:200px; max-width:38vw; }
    #sentencePanel h2 { margin:0 0 6px; font-size:12px; color:#cfcfcf; }
    #stackText {
      display:block;
      font-size:18px;
      letter-spacing:.5px;
      line-height:1.3;
      color:#fff;
      min-height:22px;
      white-space: pre; /* 연속 공백 유지 */
    }
  </style>
  <script src="https://unpkg.com/matter-js@0.20.0/build/matter.min.js"></script>
</head>
<body>
  <div id="hud">
    <h1>Letters · Typing System</h1>
  </div>

  <div id="sentencePanel">
    <h2>Channel Sentence</h2>
    <span id="stackText"></span>
  </div>

  <div id="stage"></div>

  <script>
  (() => {
    const { Engine, Render, Runner, Bodies, Body, Composite, Events, Mouse, MouseConstraint } = Matter;
    const deg = d => d * Math.PI / 180;

    // ======== SCALE ========
    let VIEW_W = window.innerWidth;
    let VIEW_H = window.innerHeight;
    function calcScale() {
      VIEW_W = window.innerWidth;
      VIEW_H = window.innerHeight;
      const baseW = 1280, baseH = 800;
      return Math.max(0.5, Math.min(1.0, Math.min(VIEW_W / baseW, VIEW_H / baseH) * 0.82));
    }
    let SCALE = calcScale();

    // ======== ENGINE/RENDER ========
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const stage = document.getElementById('stage');
    const engine = Engine.create();
    engine.gravity.y = 1.7;
    engine.enableSleeping = false;
    engine.positionIterations = 12;
    engine.velocityIterations = 10;
    engine.constraintIterations = 4;

    const render = Render.create({
      element: stage, engine,
      options: { width: VIEW_W, height: VIEW_H, background:'#0b0b0b', wireframes:false, pixelRatio:DPR }
    });
    Render.run(render);
    const runner = Runner.create(); Runner.run(runner, engine);

    // ======== DIMENSIONS ========
    const BASE_R   = Math.max(9, Math.round(20 * SCALE));
    const BASE_D   = BASE_R * 2;
    const KB_Y     = Math.round(64 * SCALE);
    const KB_KEYH  = Math.max(26, Math.round(32 * SCALE));
    const KB_GAP   = Math.max(4,  Math.round(7  * SCALE));
    const V_ANGLE  = deg(30);
    const RAMP_LEN = Math.min(820 * SCALE, VIEW_W * 0.72);
    const RAMP_H   = Math.max(12, Math.round(16 * SCALE));
    const THROAT_T = Math.max(7,  Math.round(9  * SCALE));
    const HOLE_D   = BASE_D + Math.round(4 * SCALE);
    const THROAT_GAP = HOLE_D + 2;
    const THROAT_LEN = Math.max(64, Math.round(76 * SCALE));
    const CHAN_LEN = Math.max(300 * SCALE, Math.min(VIEW_H * 0.46, 500 * SCALE));
    const BOTTOM_H = Math.max(40, Math.round(48 * SCALE));

    // ======== KEYBOARD LAYOUT ========
    const KB_ROWS = ["`1234567890-=", "qwertyuiop[]\\", "asdfghjkl;'", "zxcvbnm,./"];
    const KB = { x:0, y:KB_Y, w:0, keyH:KB_KEYH, gap:KB_GAP, offsets:[0,0.5,0.9,1.4], keyW:[] };

    function computeKBGeom(){
      const margin = Math.round(16 * SCALE);
      KB.w = Math.min(Math.round(840 * SCALE), VIEW_W - margin*2);
      KB.x = (VIEW_W - KB.w)/2;
      KB.keyH = KB_KEYH;
      KB.gap = KB_GAP;
      KB.offsets = [0,0.5,0.9,1.4];
      KB.keyW = KB_ROWS.map(r => (KB.w - (r.length-1)*KB.gap) / r.length);
    }
    computeKBGeom();

    function normalizeKey(k){ if(k===' ') return ' '; return (k.length===1 ? k.toLowerCase() : k); }
    function keyToPosition(k){
      const key = normalizeKey(k);
      if (key === ' '){
        const row = 3, y = KB.y + row*(KB.keyH+KB.gap) + KB.keyH + Math.round(14 * SCALE), x = KB.x + KB.w/2;
        return { x, y };
      }
      for (let row=0; row<KB_ROWS.length; row++){
        const idx = KB_ROWS[row].indexOf(key);
        if (idx !== -1){
          const w = KB.keyW[row], rowOffset = KB.offsets[row]*(w+KB.gap);
          const x = KB.x + rowOffset + idx*(w+KB.gap) + w/2;
          const y = KB.y + row*(KB.keyH+KB.gap) + KB.keyH/2 + Math.round(6*SCALE);
          return { x, y };
        }
      }
      return { x: VIEW_W*0.5, y: 50 * SCALE };
    }

    // 좌/우 Shift 공 스폰 위치
    function shiftSpawnPos(side){
      if (side === 'right'){
        const slash = keyToPosition('/'); // 오른쪽 시프트 근처
        return { x: slash.x + (KB.keyW[3] || 40)*0.9, y: slash.y };
      } else {
        const zPos = keyToPosition('z');  // 왼쪽 시프트 근처
        return { x: zPos.x - (KB.keyW[3] || 40)*0.9, y: zPos.y };
      }
    }

    // ======== FUNNEL / CHANNEL / FLOOR ========
    let walls = {};
    const channelMetrics = { xL:0, xR:0, yTop:0, yBot:0 };

    function makeFunnel(){
      const wallMat = {
        isStatic:true,
        friction:0, frictionStatic:0, restitution:0,
        chamfer:{ radius: Math.max(2, Math.round(3*SCALE)) },
        render:{ fillStyle:'#1a1a1a' }
      };
      const thickness = Math.round(64 * SCALE);

      walls.left   = Bodies.rectangle(-thickness/2, VIEW_H/2, thickness, VIEW_H*2, wallMat);
      walls.right  = Bodies.rectangle(VIEW_W+thickness/2, VIEW_H/2, thickness, VIEW_H*2, wallMat);
      walls.ceiling= Bodies.rectangle(VIEW_W/2, -thickness/2, VIEW_W, thickness, wallMat);

      const cx = VIEW_W/2;

      const tipY = Math.min(VIEW_H*0.46, VIEW_H - Math.round(220*SCALE));
      const tipClear = Math.max(8, Math.round(9*SCALE));

      const halfHole = HOLE_D/2;

      const uL = { x: Math.cos(V_ANGLE),  y: Math.sin(V_ANGLE)  };
      const uR = { x: Math.cos(-V_ANGLE), y: Math.sin(-V_ANGLE) };

      const E_left  = { x: cx - halfHole - tipClear, y: tipY };
      const E_right = { x: cx + halfHole + tipClear, y: tipY };
      const C_left  = { x: E_left.x  - (RAMP_LEN/2)*uL.x, y: E_left.y  - (RAMP_LEN/2)*uL.y };
      const C_right = { x: E_right.x + (RAMP_LEN/2)*uR.x, y: E_right.y + (RAMP_LEN/2)*uR.y };

      walls.rampL = Bodies.rectangle(C_left.x,  C_left.y,  RAMP_LEN, RAMP_H, { ...wallMat, angle:  V_ANGLE });
      walls.rampR = Bodies.rectangle(C_right.x, C_right.y, RAMP_LEN, RAMP_H, { ...wallMat, angle: -V_ANGLE });

      const throatGap = THROAT_GAP;
      const throatLen = THROAT_LEN;
      const throatMidY = tipY + throatLen/2 + Math.round(6*SCALE);
      const throatX_L = cx - throatGap/2 - THROAT_T/2;
      const throatX_R = cx + throatGap/2 + THROAT_T/2;

      walls.throatL = Bodies.rectangle(throatX_L, throatMidY, THROAT_T, throatLen, wallMat);
      walls.throatR = Bodies.rectangle(throatX_R, throatMidY, THROAT_T, throatLen, wallMat);

      const channelGap = throatGap - 2;
      const channelLen = CHAN_LEN;
      const chanX_L = cx - channelGap/2 - THROAT_T/2;
      const chanX_R = cx + channelGap/2 + THROAT_T/2;
      const chanMidY = throatMidY + throatLen/2 + channelLen/2;

      walls.railL = Bodies.rectangle(chanX_L, chanMidY, THROAT_T, channelLen, wallMat);
      walls.railR = Bodies.rectangle(chanX_R, chanMidY, THROAT_T, channelLen, wallMat);

      walls.bottom = Bodies.rectangle(VIEW_W/2, chanMidY + channelLen/2 + BOTTOM_H/2, VIEW_W, BOTTOM_H, wallMat);

      Composite.add(engine.world, [
        walls.left, walls.right, walls.ceiling,
        walls.rampL, walls.rampR,
        walls.throatL, walls.throatR,
        walls.railL, walls.railR, walls.bottom
      ]);

      channelMetrics.xL   = cx - channelGap/2;
      channelMetrics.xR   = cx + channelGap/2;
      channelMetrics.yTop = chanMidY - channelLen/2;
      channelMetrics.yBot = chanMidY + channelLen/2;
    }
    makeFunnel();

    // ======== TOKENS ========
    const tokens = [];
    function hashColor(char){ const code=(char||' ').charCodeAt(0); const h=(code*37)%360; return `hsl(${h} 68% 54%)`; }

    function spawnToken(char, opts={}){
      const x = (opts.x ?? VIEW_W*0.5);
      const y = (opts.y ?? 50*SCALE);
      const circle = Bodies.circle(x, y, BASE_R, {
        restitution:0.04,
        friction:0.035,
        frictionAir:0.0045,
        density:0.00155,
        render:{ fillStyle:hashColor(char), strokeStyle:'#333', lineWidth:1 }
      });
      // 저장: 스페이스는 특수 기호, 그 외엔 현재 표시문자 그대로 저장
      circle.__label = (char === ' ') ? '␣' : String(char);
      circle.__isToken = true;
      tokens.push(circle);
      Composite.add(engine.world, circle);
    }
    function removeToken(b){ if(!b) return; Composite.remove(engine.world, b); const i=tokens.indexOf(b); if(i>=0) tokens.splice(i,1); }

    // Backspace ball (글자류 삭제 전용)
    function backspaceSpawnPos(){
      const w=KB.keyW[0], rowOffset=KB.offsets[0]*(w+KB.gap), top=KB_ROWS[0];
      const x = KB.x + rowOffset + (top.length)*(w+KB.gap) + w*0.6;
      const y = KB.y + KB.keyH/2 + Math.round(6*SCALE);
      return { x, y };
    }
    function spawnBackspaceBall(){
      const p = backspaceSpawnPos();
      const ball = Bodies.circle(p.x, p.y, BASE_R, {
        restitution:0.04,
        friction:0.035,
        frictionAir:0.0045,
        density:0.0017,
        render:{ fillStyle:'#ff5566', strokeStyle:'#74242a', lineWidth:2 }
      });
      ball.__label = '⌫';
      ball.__isBackspace = true;
      Composite.add(engine.world, ball);
    }

    // Shift ball (⇧) — 충돌 시 대상 글자/숫자를 Shift 변환하고 본인은 소멸
    function spawnShiftBall(side='left'){
      const p = shiftSpawnPos(side);
      const ball = Bodies.circle(p.x, p.y, BASE_R, {
        restitution:0.04,
        friction:0.035,
        frictionAir:0.0045,
        density:0.0017,
        render:{ fillStyle:'#3a6df0', strokeStyle:'#1f3180', lineWidth:2 }
      });
      ball.__label = '⇧';
      ball.__isShift = true;   // __isToken이 아님 → ⌫에 의해 제거되지 않음
      tokens.push(ball);       // 물리/체인 위치 판단을 위해 tokens에는 포함
      Composite.add(engine.world, ball);
    }

    // 마우스 드래그
    const mouse = Mouse.create(render.canvas);
    const mc = MouseConstraint.create(engine, { mouse, constraint:{ stiffness:0.12, angularStiffness:0.06, render:{ visible:false } } });
    Composite.add(engine.world, mc);
    render.mouse = mouse;

    // ======== 라벨 렌더 ========
    Events.on(render, 'afterRender', () => {
      const ctx = render.context;

      // 미니 키보드
      ctx.save();
      for (let row=0; row<KB_ROWS.length; row++){
        const rowStr = KB_ROWS[row], w = KB.keyW[row];
        const rowOffset = KB.offsets[row]*(w+KB.gap);
        const y = KB.y + row*(KB.keyH+KB.gap);
        for (let i=0; i<rowStr.length; i++){
          const x = KB.x + rowOffset + i*(w+KB.gap);
          const r = Math.max(5, Math.round(7*SCALE));
          ctx.fillStyle = 'rgba(255,255,255,0.05)';
          ctx.beginPath();
          ctx.moveTo(x+r, y);
          ctx.arcTo(x+w, y, x+w, y+KB.keyH, r);
          ctx.arcTo(x+w, y+KB.keyH, x, y+KB.keyH, r);
          ctx.arcTo(x, y+KB.keyH, x, y, r);
          ctx.arcTo(x, y, x+w, y, r);
          ctx.closePath();
          ctx.fill();
        }
      }
      ctx.restore();

      // 토큰 라벨
      ctx.save();
      ctx.textAlign='center'; ctx.textBaseline='middle';
      Composite.allBodies(engine.world).forEach(b => {
        if (!b.__label) return;
        const r = b.circleRadius || BASE_R;
        ctx.save();
        ctx.translate(b.position.x, b.position.y);
        ctx.rotate(b.angle);
        ctx.fillStyle = '#16161666';
        ctx.beginPath(); ctx.arc(0,0,r*0.8,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#f5f5f5';
        ctx.font = `${Math.floor(r*0.95)}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Noto Sans KR, Roboto`;
        ctx.fillText(String(b.__label), 0, 0);
        ctx.restore();
      });
      ctx.restore();
    });

    // ======== Shift 변환 로직 ========
    const digitShiftMap = { '1':'!', '2':'@', '3':'#', '4':'$', '5':'%', '6':'^', '7':'&', '8':'*', '9':'(', '0':')' };
    function applyShiftToLabel(lbl){
      if (lbl === '␣') return '␣';                 // 스페이스는 그대로
      if (/^[a-z]$/.test(lbl)) return lbl.toUpperCase();
      if (/^[A-Z]$/.test(lbl)) return lbl.toLowerCase();
      if (digitShiftMap[lbl]) return digitShiftMap[lbl];
      return lbl;                                  // 그 외(기호 등)는 그대로
    }

    // ======== 충돌 규칙 ========
    Events.on(engine, 'collisionStart', (evt) => {
      evt.pairs.forEach(({ bodyA:a, bodyB:b }) => {
        // Backspace vs 글자류
        if (a.__isBackspace && b.__isToken && !a.__spent){
          a.__spent = true; removeToken(b); Composite.remove(engine.world, a); return;
        }
        if (b.__isBackspace && a.__isToken && !b.__spent){
          b.__spent = true; removeToken(a); Composite.remove(engine.world, b); return;
        }

        // Shift vs 글자/숫자/스페이스(⇧는 대상의 라벨만 바꾸고 즉시 소멸)
        if (a.__isShift && b.__isToken){
          b.__label = applyShiftToLabel(b.__label);
          Composite.remove(engine.world, a);
          const ia = tokens.indexOf(a); if (ia>=0) tokens.splice(ia,1);
          return;
        }
        if (b.__isShift && a.__isToken){
          a.__label = applyShiftToLabel(a.__label);
          Composite.remove(engine.world, b);
          const ib = tokens.indexOf(b); if (ib>=0) tokens.splice(ib,1);
          return;
        }
      });
    });

    // ======== 문장 만들기: 채널의 1열 체인(글자 공만) ========
    const stackTextEl = document.getElementById('stackText');

    function tokenLabelToChar(lbl){
      if (lbl === '␣') return ' ';
      return String(lbl);
    }

    function updateSentence(){
      const { xL, xR, yTop, yBot } = channelMetrics;
      const padX = 2, padY = 2;

      // 채널 내부의 "글자 공"만 대상으로(⇧, ⌫ 등은 제외)
      const inside = tokens.filter(b => b.__isToken && (
        b.position.x >= xL - padX && b.position.x <= xR + padX &&
        b.position.y >= yTop - padY && b.position.y <= yBot + padY
      ));
      if (inside.length === 0){ stackTextEl.textContent = ''; return; }

      // 아래→위
      inside.sort((a, b) => b.position.y - a.position.y);

      // 맞닿은 연속 체인
      const chain = [];
      const TOUCH_EPS = 1.8;
      const ALIGN_EPS = BASE_R * 0.6;

      let prev = inside[0];
      chain.push(prev);
      for (let i = 1; i < inside.length; i++){
        const cur = inside[i];
        const dx = Math.abs(cur.position.x - prev.position.x);
        const dist = Math.hypot(cur.position.x - prev.position.x, cur.position.y - prev.position.y);
        const touching = (dx <= ALIGN_EPS) && (dist <= (BASE_D + TOUCH_EPS));
        if (touching){ chain.push(cur); prev = cur; } else { break; }
      }

      // 바닥 접촉 확인(맨 아래가 바닥에 닿아야 문장 표시)
      const bottomTopY = walls.bottom.bounds.min.y;
      const first = chain[0];
      const touchingFloor = (first.position.y + BASE_R) >= (bottomTopY - 0.6);
      if (!touchingFloor){ stackTextEl.textContent = ''; return; }

      stackTextEl.textContent = chain.map(b => tokenLabelToChar(b.__label)).join('');
    }

    const MAX_VX = 16 * SCALE, MAX_VY = 22 * SCALE;
    Events.on(engine, 'beforeUpdate', () => {
      Composite.allBodies(engine.world).forEach(b => {
        if (!b.isStatic){
          const vx = Math.min(MAX_VX, Math.max(-MAX_VX, b.velocity.x));
          const vy = Math.min(MAX_VY, Math.max(-MAX_VY, b.velocity.y));
          if (vx !== b.velocity.x || vy !== b.velocity.y) Body.setVelocity(b, { x: vx, y: vy });
        }
      });
    });
    Events.on(engine, 'afterUpdate', updateSentence);

    // ======== INPUT ========
    let lastTime = performance.now();
    document.addEventListener('keydown', (e) => {
      // Shift → ⇧ 공 스폰 (좌/우 구분)
      if (e.key === 'Shift' || e.code === 'ShiftLeft'){ spawnShiftBall('left'); return; }
      if (e.code === 'ShiftRight'){ spawnShiftBall('right'); return; }

      // 제어키
      if (e.key === 'Backspace' || e.code === 'Backspace'){ e.preventDefault(); spawnBackspaceBall(); return; }
      if (e.key === 'Enter' || e.code === 'Enter'){ resetAll(); return; }
      if (e.key === ' ' || e.code === 'Space'){ const p=keyToPosition(' '); spawnToken(' ',{x:p.x,y:p.y}); return; }

      // 알파벳/숫자
      let ch = null;
      if (/^[a-zA-Z]$/.test(e.key)) {
        ch = e.key.toLowerCase();                    // 기본은 소문자로 스폰
      } else if (/^Key[A-Z]$/.test(e.code)) {
        ch = e.code.slice(3).toLowerCase();
      } else if (/^[0-9]$/.test(e.key)) {
        ch = e.key;
      } else if (/^Digit[0-9]$/.test(e.code)) {
        ch = e.code.slice(5, 6);
      } else if (/^Numpad[0-9]$/.test(e.code)) {
        ch = e.code.slice(6, 7);
      }
      if (!ch) return;

      const now = performance.now();
      const dt = now - lastTime;
      lastTime = now;

      const p = keyToPosition(ch);
      const spread = Math.max(-28*SCALE, Math.min(28*SCALE, (dt-120)*0.45));
      spawnToken(ch, { x: p.x + spread, y: p.y });
    });

    // ======== RESIZE/RESET ========
    function rebuildAll(){
      SCALE = calcScale();

      render.options.width = VIEW_W; render.options.height = VIEW_H;
      render.canvas.width = VIEW_W * DPR; render.canvas.height = VIEW_H * DPR;
      render.canvas.style.width = VIEW_W + 'px'; render.canvas.style.height = VIEW_H + 'px';

      Composite.remove(engine.world, [
        walls.left, walls.right, walls.ceiling,
        walls.rampL, walls.rampR,
        walls.throatL, walls.throatR,
        walls.railL, walls.railR, walls.bottom
      ].filter(Boolean));

      KB.y = Math.round(64 * SCALE);
      computeKBGeom();

      makeFunnel();
      updateSentence();
    }
    window.addEventListener('resize', rebuildAll);

    function resetAll(){
      tokens.splice(0).forEach(b => Composite.remove(engine.world, b));
      Composite.allBodies(engine.world).forEach(b => { if (b.__isBackspace) Composite.remove(engine.world, b); });
      updateSentence();
    }
  })();
  </script>
</body>
</html>
