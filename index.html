<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Letters · Typing System – Left Shift + Digit Toggle</title>
  <style>
    :root { --bg:#0b0b0b; --fg:#eaeaea; --muted:#9aa0a6; }
    html, body { height:100%; }
    body { margin:0; background:var(--bg); color:var(--fg);
           font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,Helvetica,Arial,sans-serif;
           overflow:hidden; }
    #stage { position:relative; width:100%; height:100%; }
    #hud, #sentencePanel {
      position:fixed; z-index:10; background:#121212cc;
      border:1px solid #2a2a2a; border-radius:10px; backdrop-filter: blur(8px);
    }
    #hud { left:10px; top:10px; padding:8px 10px; max-width:48vw; }
    #hud h1 { margin:0 0 4px; font-size:12px; color:#bdbdbd; }
    #hud p  { margin:0; font-size:11px; color:#cfcfcf; }
    #sentencePanel { right:10px; top:10px; padding:8px 10px; min-width:200px; max-width:38vw; }
    #sentencePanel h2 { margin:0 0 6px; font-size:12px; color:#cfcfcf; }
    #stackText {
      display:block; font-size:18px; letter-spacing:.5px; line-height:1.3; color:#fff;
      min-height:22px; white-space: pre; /* 연속 공백 유지 */
    }
  </style>
  <script src="https://unpkg.com/matter-js@0.20.0/build/matter.min.js"></script>
</head>
<body>
  <div id="hud">
    <h1>Letters · Typing System</h1>
  </div>

  <div id="sentencePanel">
    <h2>Channel Sentence</h2>
    <span id="stackText"></span>
  </div>

  <div id="stage"></div>

  <script>
  (() => {
    const { Engine, Render, Runner, Bodies, Body, Composite, Events, Mouse, MouseConstraint } = Matter;
    const deg = d => d * Math.PI / 180;

    // ======== SCALE ========
    let VIEW_W = window.innerWidth;
    let VIEW_H = window.innerHeight;
    function calcScale() {
      VIEW_W = window.innerWidth;
      VIEW_H = window.innerHeight;
      const baseW = 1280, baseH = 800;
      return Math.max(0.5, Math.min(1.0, Math.min(VIEW_W / baseW, VIEW_H / baseH) * 0.82));
    }
    let SCALE = calcScale();

    // ======== ENGINE/RENDER ========
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const stage = document.getElementById('stage');
    const engine = Engine.create();
    engine.gravity.y = 1.7;
    engine.enableSleeping = false;
    engine.positionIterations = 12;
    engine.velocityIterations = 10;
    engine.constraintIterations = 4;

    const render = Render.create({
      element: stage, engine,
      options: { width: VIEW_W, height: VIEW_H, background:'#0b0b0b', wireframes:false, pixelRatio:DPR }
    });
    Render.run(render);
    const runner = Runner.create(); Runner.run(runner, engine);

    // ======== DIMENSIONS ========
    const BASE_R   = Math.max(9, Math.round(20 * SCALE));
    const BASE_D   = BASE_R * 2;
    const KB_Y     = Math.round(64 * SCALE);
    const KB_KEYH  = Math.max(26, Math.round(32 * SCALE));
    const KB_GAP   = Math.max(4,  Math.round(7  * SCALE));
    const V_ANGLE  = deg(30);
    const RAMP_LEN = Math.min(820 * SCALE, VIEW_W * 0.72);
    const RAMP_H   = Math.max(12, Math.round(16 * SCALE));
    const THROAT_T = Math.max(7,  Math.round(9  * SCALE));
    const HOLE_D   = BASE_D + Math.round(4 * SCALE);
    const THROAT_GAP = HOLE_D + 2;
    const THROAT_LEN = Math.max(64, Math.round(76 * SCALE));
    const CHAN_LEN = Math.max(300 * SCALE, Math.min(VIEW_H * 0.46, 500 * SCALE));
    const BOTTOM_H = Math.max(40, Math.round(48 * SCALE));

    // ======== KEYBOARD LAYOUT ========
    const KB_ROWS = ["`1234567890-=", "qwertyuiop[]\\", "asdfghjkl;'", "zxcvbnm,./"];
    const KB = { x:0, y:KB_Y, w:0, keyH:KB_KEYH, gap:KB_GAP, offsets:[0,0.5,0.9,1.4], keyW:[] };

    function computeKBGeom(){
      const margin = Math.round(16 * SCALE);
      KB.w = Math.min(Math.round(840 * SCALE), VIEW_W - margin*2);
      KB.x = (VIEW_W - KB.w)/2;
      KB.keyH = KB_KEYH;
      KB.gap = KB_GAP;
      KB.offsets = [0,0.5,0.9,1.4];
      KB.keyW = KB_ROWS.map(r => (KB.w - (r.length-1)*KB.gap) / r.length);
    }
    computeKBGeom();

    // 허용 키만 스폰/표시
    const ALPHA = new Set('abcdefghijklmnopqrstuvwxyz'.split(''));
    const DIGIT = new Set('0123456789'.split(''));
    const isSpawnKey = (k) => ALPHA.has(k) || DIGIT.has(k);
    function normalizeKey(k){ if(k===' ') return ' '; return (k.length===1 ? k.toLowerCase() : k); }

    function keyToPosition(k){
      const key = normalizeKey(k);
      if (key === ' '){
        const row = 3, y = KB.y + row*(KB.keyH+KB.gap) + KB.keyH + Math.round(14 * SCALE), x = KB.x + KB.w/2;
        return { x, y };
      }
      if (!isSpawnKey(key)) return { x: VIEW_W*0.5, y: 50*SCALE };
      for (let row=0; row<KB_ROWS.length; row++){
        const idx = KB_ROWS[row].indexOf(key);
        if (idx !== -1){
          const w = KB.keyW[row], rowOffset = KB.offsets[row]*(w+KB.gap);
          const x = KB.x + rowOffset + idx*(w+KB.gap) + w/2;
          const y = KB.y + row*(KB.keyH+KB.gap) + KB.keyH/2 + Math.round(6*SCALE);
          return { x, y };
        }
      }
      return { x: VIEW_W*0.5, y: 50 * SCALE };
    }

    // ======== Shift/Backspace 스폰 좌표 ========
    // 왼쪽 Shift만 사용 (오른쪽 Shift 제거)
    function shiftSpawnPos(){
      const row = 3;
      const w = KB.keyW[row], h = KB.keyH, gap = KB.gap;
      const rowOffset = KB.offsets[row]*(w+gap);
      const zCol = KB_ROWS[3].indexOf('z');
      const y = KB.y + row*(h+gap) + h/2 + Math.round(6*SCALE);
      const x = KB.x + rowOffset + (zCol)*(w+gap) - w*0.9; // Z 왼쪽(왼쪽 Shift 자리)
      return { x, y };
    }
    function backspaceSpawnPos(){
      const w=KB.keyW[0], rowOffset=KB.offsets[0]*(w+KB.gap), top=KB_ROWS[0];
      const x = KB.x + rowOffset + (top.length)*(w+KB.gap) + w*0.6;
      const y = KB.y + KB.keyH/2 + Math.round(6*SCALE);
      return { x, y };
    }

    // ======== FUNNEL / CHANNEL / FLOOR ========
    let walls = {};
    const channelMetrics = { xL:0, xR:0, yTop:0, yBot:0 };

    function makeFunnel(){
      const wallMat = {
        isStatic:true,
        friction:0, frictionStatic:0, restitution:0,
        chamfer:{ radius: Math.max(2, Math.round(3*SCALE)) },
        render:{ fillStyle:'#1a1a1a' }
      };
      const thickness = Math.round(64 * SCALE);

      walls.left   = Bodies.rectangle(-thickness/2, VIEW_H/2, thickness, VIEW_H*2, wallMat);
      walls.right  = Bodies.rectangle(VIEW_W+thickness/2, VIEW_H/2, thickness, VIEW_H*2, wallMat);
      walls.ceiling= Bodies.rectangle(VIEW_W/2, -thickness/2, VIEW_W, thickness, wallMat);

      const cx = VIEW_W/2;

      const tipY = Math.min(VIEW_H*0.46, VIEW_H - Math.round(220*SCALE));
      const tipClear = Math.max(8, Math.round(9*SCALE));
      const halfHole = HOLE_D/2;

      const uL = { x: Math.cos(V_ANGLE),  y: Math.sin(V_ANGLE)  };
      const uR = { x: Math.cos(-V_ANGLE), y: Math.sin(-V_ANGLE) };

      const E_left  = { x: cx - halfHole - tipClear, y: tipY };
      const E_right = { x: cx + halfHole + tipClear, y: tipY };
      const C_left  = { x: E_left.x  - (RAMP_LEN/2)*uL.x, y: E_left.y  - (RAMP_LEN/2)*uL.y };
      const C_right = { x: E_right.x + (RAMP_LEN/2)*uR.x, y: E_right.y + (RAMP_LEN/2)*uR.y };

      walls.rampL = Bodies.rectangle(C_left.x,  C_left.y,  RAMP_LEN, RAMP_H, { ...wallMat, angle:  V_ANGLE });
      walls.rampR = Bodies.rectangle(C_right.x, C_right.y, RAMP_LEN, RAMP_H, { ...wallMat, angle: -V_ANGLE });

      const throatGap = THROAT_GAP;
      const throatLen = THROAT_LEN;
      const throatMidY = tipY + throatLen/2 + Math.round(6*SCALE);
      const throatX_L = cx - throatGap/2 - THROAT_T/2;
      const throatX_R = cx + throatGap/2 + THROAT_T/2;

      walls.throatL = Bodies.rectangle(throatX_L, throatMidY, THROAT_T, throatLen, wallMat);
      walls.throatR = Bodies.rectangle(throatX_R, throatMidY, THROAT_T, throatLen, wallMat);

      const channelGap = throatGap - 2;
      const channelLen = CHAN_LEN;
      const chanX_L = cx - channelGap/2 - THROAT_T/2;
      const chanX_R = cx + channelGap/2 + THROAT_T/2;
      const chanMidY = throatMidY + throatLen/2 + channelLen/2;

      walls.railL = Bodies.rectangle(chanX_L, chanMidY, THROAT_T, channelLen, wallMat);
      walls.railR = Bodies.rectangle(chanX_R, chanMidY, THROAT_T, channelLen, wallMat);

      walls.bottom = Bodies.rectangle(VIEW_W/2, chanMidY + channelLen/2 + BOTTOM_H/2, VIEW_W, BOTTOM_H, wallMat);

      Composite.add(engine.world, [
        walls.left, walls.right, walls.ceiling,
        walls.rampL, walls.rampR,
        walls.throatL, walls.throatR,
        walls.railL, walls.railR, walls.bottom
      ]);

      channelMetrics.xL   = cx - channelGap/2;
      channelMetrics.xR   = cx + channelGap/2;
      channelMetrics.yTop = chanMidY - channelLen/2;
      channelMetrics.yBot = chanMidY + channelLen/2;
    }
    makeFunnel();

    // ======== TOKENS ========
    const tokens = [];
    function hashColor(char){ const code=(char||' ').charCodeAt(0); const h=(code*37)%360; return `hsl(${h} 68% 54%)`; }

    function spawnToken(char, opts={}){
      const x = (opts.x ?? VIEW_W*0.5);
      const y = (opts.y ?? 50*SCALE);
      const circle = Bodies.circle(x, y, BASE_R, {
        restitution:0.04, friction:0.035, frictionAir:0.0045, density:0.00155,
        render:{ fillStyle:hashColor(char), strokeStyle:'#333', lineWidth:1 }
      });
      circle.__label = (char === ' ') ? '␣' : String(char);
      circle.__isToken = true;
      tokens.push(circle);
      Composite.add(engine.world, circle);
    }
    function removeToken(b){ if(!b) return; Composite.remove(engine.world, b); const i=tokens.indexOf(b); if(i>=0) tokens.splice(i,1); }

    // Backspace ball
    function spawnBackspaceBall(){
      const p = backspaceSpawnPos();
      const ball = Bodies.circle(p.x, p.y, BASE_R, {
        restitution:0.04, friction:0.035, frictionAir:0.0045, density:0.0017,
        render:{ fillStyle:'#ff5566', strokeStyle:'#74242a', lineWidth:2 }
      });
      ball.__label = '⌫';
      ball.__isBackspace = true;
      Composite.add(engine.world, ball);
    }

    // Left Shift ball only
    function spawnShiftBall(){
      const p = shiftSpawnPos();
      const ball = Bodies.circle(p.x, p.y, BASE_R, {
        restitution:0.04, friction:0.035, frictionAir:0.0045, density:0.0017,
        render:{ fillStyle:'#3a6df0', strokeStyle:'#1f3180', lineWidth:2 }
      });
      ball.__label = '⇧';
      ball.__isShift = true;
      tokens.push(ball);
      Composite.add(engine.world, ball);
    }

    // 마우스 드래그(테스트)
    const mouse = Mouse.create(render.canvas);
    const mc = MouseConstraint.create(engine, { mouse, constraint:{ stiffness:0.12, angularStiffness:0.06, render:{ visible:false } } });
    Composite.add(engine.world, mc);
    render.mouse = mouse;

    // ======== SHIFT 변환: 숫자↔기호 토글 + 알파벳 토글 ========
    const digitToSymbol = { '1':'!', '2':'@', '3':'#', '4':'$', '5':'%', '6':'^', '7':'&', '8':'*', '9':'(', '0':')' };
    const symbolToDigit = { '!':'1', '@':'2', '#':'3', '$':'4', '%':'5', '^':'6', '&':'7', '*':'8', '(':'9', ')':'0' };

    function applyShiftToLabel(lbl){
      if (lbl === '␣') return '␣';

      // 알파벳: 대↔소문자 토글
      if (/^[a-z]$/.test(lbl)) return lbl.toUpperCase();
      if (/^[A-Z]$/.test(lbl)) return lbl.toLowerCase();

      // 숫자/기호: 양방향 토글
      if (digitToSymbol[lbl]) return digitToSymbol[lbl];  // 1 -> !
      if (symbolToDigit[lbl]) return symbolToDigit[lbl];  // ! -> 1

      return lbl;
    }

    // ======== 충돌 ========
    Events.on(engine, 'collisionStart', (evt) => {
      evt.pairs.forEach(({ bodyA:a, bodyB:b }) => {
        // Backspace vs 글자류
        if (a.__isBackspace && b.__isToken && !a.__spent){
          a.__spent = true; removeToken(b); Composite.remove(engine.world, a); return;
        }
        if (b.__isBackspace && a.__isToken && !b.__spent){
          b.__spent = true; removeToken(a); Composite.remove(engine.world, b); return;
        }
        // Shift 변환 (토글)
        if (a.__isShift && b.__isToken){
          b.__label = applyShiftToLabel(b.__label);
          Composite.remove(engine.world, a);
          const ia = tokens.indexOf(a); if (ia>=0) tokens.splice(ia,1);
          return;
        }
        if (b.__isShift && a.__isToken){
          a.__label = applyShiftToLabel(a.__label);
          Composite.remove(engine.world, b);
          const ib = tokens.indexOf(b); if (ib>=0) tokens.splice(ib,1);
          return;
        }
      });
    });

    // ======== 문장 생성 ========
    const stackTextEl = document.getElementById('stackText');
    function tokenLabelToChar(lbl){ return (lbl === '␣') ? ' ' : String(lbl); }

    function updateSentence(){
      const { xL, xR, yTop, yBot } = channelMetrics;
      const padX = 2, padY = 2;
      const inside = tokens.filter(b => b.__isToken && (
        b.position.x >= xL - padX && b.position.x <= xR + padX &&
        b.position.y >= yTop - padY && b.position.y <= yBot + padY
      ));
      if (inside.length === 0){ stackTextEl.textContent = ''; return; }

      inside.sort((a, b) => b.position.y - a.position.y);

      // 맞닿은 연속 체인
      const chain = [];
      const TOUCH_EPS = 1.8;
      const ALIGN_EPS = BASE_R * 0.6;
      let prev = inside[0];
      chain.push(prev);
      for (let i = 1; i < inside.length; i++){
        const cur = inside[i];
        const dx = Math.abs(cur.position.x - prev.position.x);
        const dist = Math.hypot(cur.position.x - prev.position.x, cur.position.y - prev.position.y);
        const touching = (dx <= ALIGN_EPS) && (dist <= (BASE_D + TOUCH_EPS));
        if (touching){ chain.push(cur); prev = cur; } else { break; }
      }

      // 바닥 접촉 확인
      const bottomTopY = walls.bottom.bounds.min.y;
      const first = chain[0];
      const touchingFloor = (first.position.y + BASE_R) >= (bottomTopY - 0.6);
      if (!touchingFloor){ stackTextEl.textContent = ''; return; }

      stackTextEl.textContent = chain.map(b => tokenLabelToChar(b.__label)).join('');
    }

    const MAX_VX = 16 * SCALE, MAX_VY = 22 * SCALE;
    Events.on(engine, 'beforeUpdate', () => {
      Composite.allBodies(engine.world).forEach(b => {
        if (!b.isStatic){
          const vx = Math.min(MAX_VX, Math.max(-MAX_VX, b.velocity.x));
          const vy = Math.min(MAX_VY, Math.max(-MAX_VY, b.velocity.y));
          if (vx !== b.velocity.x || vy !== b.velocity.y) Body.setVelocity(b, { x: vx, y: vy });
        }
      });
    });
    Events.on(engine, 'afterUpdate', updateSentence);

    // ======== 키보드(오버레이: 오른쪽 Shift 제거) ========
    const pressedAt = new Map();
    const PRESS_FLASH_MS = 150;

    function roundRect(ctx, x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y,   x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x,   y+h, r);
      ctx.arcTo(x,   y+h, x,   y,   r);
      ctx.arcTo(x,   y,   x+w, y,   r);
      ctx.closePath();
    }
    function drawKey(ctx, x,y,w,h, label, isBright=false){
      const r = Math.max(5, Math.round(7*SCALE));
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.fillStyle = isBright ? 'rgba(255,255,255,0.18)' : 'rgba(255,255,255,0.10)';
      roundRect(ctx, x, y, w, h, r);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = '#e6e6e6';
      ctx.font = `${Math.floor(h*0.42)}px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(label, x + w/2, y + h/2 + 0.5);
    }
    const ALLOWED_FOR_OVERLAY = new Set([
      ...'abcdefghijklmnopqrstuvwxyz'.split(''), ...'0123456789'.split(''),
      // 특수키는 아래에서 별도로 그림(Backspace, Left Shift)
    ]);

    function drawKeyboard(ctx){
      // 알파벳/숫자만 그림
      for (let row=0; row<KB_ROWS.length; row++){
        const rowStr = KB_ROWS[row];
        const w = KB.keyW[row], h = KB.keyH, gap = KB.gap;
        const rowOffset = KB.offsets[row]*(w+gap);
        for (let i=0; i<rowStr.length; i++){
          const k = rowStr[i]; const kl = k.toLowerCase();
          if (!(ALLOWED_FOR_OVERLAY.has(kl))) continue;
          const x = KB.x + rowOffset + i*(w+gap);
          const y = KB.y + row*(h+gap);
          const keyId = kl;
          const t = pressedAt.get(keyId) || 0;
          const isBright = (performance.now() - t) < PRESS_FLASH_MS;
          const label = (/[a-z]/.test(kl)) ? kl.toUpperCase() : k.toUpperCase();
          drawKey(ctx, x, y, w, h, label, isBright);
        }
      }
      // 스페이스바
      {
        const w = KB.keyW[3], h = KB.keyH, gap = KB.gap;
        const row = 3;
        const rowOffset = KB.offsets[row]*(w+gap);
        const spaceW = w*5.5 + gap*4.5;
        const cx = KB.x + KB.w/2 - spaceW/2;
        const y  = KB.y + row*(h+gap) + h + Math.round(6*SCALE);
        const keyId = ' ';
        const t = pressedAt.get(keyId) || 0;
        drawKey(ctx, cx, y, spaceW, h*0.9, 'SPACE', (performance.now()-t)<PRESS_FLASH_MS);
      }
      // Backspace
      {
        const w = KB.keyW[0], h = KB.keyH, gap = KB.gap;
        const row = 0;
        const rowOffset = KB.offsets[row]*(w+gap);
        const col = KB_ROWS[0].length;
        const x = KB.x + rowOffset + col*(w+gap);
        const y = KB.y + row*(h+gap);
        const bw = w*1.6 + gap*0.6;
        const t = pressedAt.get('Backspace') || 0;
        drawKey(ctx, x, y, bw, h, 'BACKSPACE', (performance.now()-t)<PRESS_FLASH_MS);
      }
      // Left Shift (오른쪽 Shift는 그리지 않음)
      {
        const w = KB.keyW[3], h = KB.keyH, gap = KB.gap;
        const row = 3;
        const rowOffset = KB.offsets[row]*(w+gap);
        const zCol = KB_ROWS[3].indexOf('z');
        const leftW = w*1.6 + gap*0.6;
        const leftX = KB.x + rowOffset + (zCol)*(w+gap) - (leftW + gap);
        const leftY = KB.y + row*(h+gap);
        drawKey(ctx, leftX, leftY, leftW, h, 'SHIFT', (performance.now()-(pressedAt.get('ShiftLeft')||0))<PRESS_FLASH_MS);
      }
    }

    Events.on(render, 'afterRender', () => {
      const ctx = render.context;
      drawKeyboard(ctx);
      // 토큰 라벨
      ctx.save();
      ctx.textAlign='center'; ctx.textBaseline='middle';
      Composite.allBodies(engine.world).forEach(b => {
        if (!b.__label) return;
        const r = b.circleRadius || BASE_R;
        ctx.save();
        ctx.translate(b.position.x, b.position.y);
        ctx.rotate(b.angle);
        ctx.fillStyle = '#16161666';
        ctx.beginPath(); ctx.arc(0,0,r*0.8,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#f5f5f5';
        ctx.font = `${Math.floor(r*0.95)}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Noto Sans KR, Roboto`;
        ctx.fillText(String(b.__label), 0, 0);
        ctx.restore();
      });
      ctx.restore();
    });

    // ======== INPUT ========
    let lastTime = performance.now();
    document.addEventListener('keydown', (e) => {
      // 하이라이트 기록
      if (e.key.length === 1) pressedAt.set(e.key.toLowerCase(), performance.now());
      else {
        pressedAt.set(e.code || e.key, performance.now());
        if (e.key === 'Backspace') pressedAt.set('Backspace', performance.now());
        if (e.code === 'ShiftLeft' || e.key === 'Shift') pressedAt.set('ShiftLeft', performance.now());
      }

      // 오른쪽 Shift는 무시, 왼쪽/일반 Shift만 처리
      if (e.code === 'ShiftLeft' || e.key === 'Shift') { spawnShiftBall(); return; }

      // 제어키
      if (e.key === 'Backspace' || e.code === 'Backspace'){ e.preventDefault(); spawnBackspaceBall(); return; }
      if (e.key === 'Enter' || e.code === 'Enter'){ resetAll(); return; }
      if (e.key === ' ' || e.code === 'Space'){ const p=keyToPosition(' '); spawnToken(' ',{x:p.x,y:p.y}); return; }

      // 알파벳/숫자
      let ch = null;
      if (/^[a-zA-Z]$/.test(e.key)) {
        ch = e.key.toLowerCase();
      } else if (/^Key[A-Z]$/.test(e.code)) {
        ch = e.code.slice(3).toLowerCase();
      } else if (/^[0-9]$/.test(e.key)) {
        ch = e.key;
      } else if (/^Digit[0-9]$/.test(e.code)) {
        ch = e.code.slice(5, 6);
      } else if (/^Numpad[0-9]$/.test(e.code)) {
        ch = e.code.slice(6, 7);
      }
      if (!ch) return;

      const p = keyToPosition(ch);
      spawnToken(ch, { x: p.x, y: p.y });
      lastTime = performance.now();
    });

    // ======== RESIZE/RESET ========
    function rebuildAll(){
      SCALE = calcScale();
      render.options.width = VIEW_W; render.options.height = VIEW_H;
      render.canvas.width = VIEW_W * DPR; render.canvas.height = VIEW_H * DPR;
      render.canvas.style.width = VIEW_W + 'px'; render.canvas.style.height = VIEW_H + 'px';

      Composite.remove(engine.world, [
        walls.left, walls.right, walls.ceiling,
        walls.rampL, walls.rampR,
        walls.throatL, walls.throatR,
        walls.railL, walls.railR, walls.bottom
      ].filter(Boolean));

      KB.y = Math.round(64 * SCALE);
      computeKBGeom();
      makeFunnel();
      updateSentence();
    }
    window.addEventListener('resize', rebuildAll);

    function resetAll(){
      tokens.splice(0).forEach(b => Composite.remove(engine.world, b));
      Composite.allBodies(engine.world).forEach(b => { if (b.__isBackspace) Composite.remove(engine.world, b); });
      updateSentence();
    }
  })();
  </script>
</body>
</html>
